import Foundation
import CoreSpotlight
import MobileCoreServices
import AppKit

@MainActor
class SpotlightManager: ObservableObject {
    static let shared = SpotlightManager()
    
    @Published var isSpotlightIndexingEnabled: Bool = false
    @Published var indexedTranscriptionCount: Int = 0
    @Published var lastIndexingUpdate: Date?
    
    private let searchableIndex = CSSearchableIndex.default()
    private let transcriptionDomain = "com.whisperlocalmacos.transcriptions"
    
    private init() {
        setupSpotlightIntegration()
    }
    
    // MARK: - Spotlight Integration Setup
    
    private func setupSpotlightIntegration() {
        // Check if Spotlight indexing is available
        isSpotlightIndexingEnabled = CSSearchableIndex.isIndexingAvailable()
        
        if isSpotlightIndexingEnabled {
            Logger.shared.info("Spotlight integration enabled", category: .system)
            loadExistingIndexCount()
        } else {
            Logger.shared.warning("Spotlight indexing not available on this system", category: .system)
        }
    }
    
    private func loadExistingIndexCount() {
        // Query existing indexed items
        let query = CSSearchQuery(
            queryString: "contentType:'\(transcriptionDomain)'",
            attributes: ["kMDItemDisplayName"]
        )
        
        var count = 0
        query.foundItemsHandler = { items in
            count += items.count
        }
        
        query.completionHandler = { [weak self] error in
            DispatchQueue.main.async {
                if let error = error {
                    Logger.shared.error("Failed to query existing Spotlight items: \(error)", category: .system)
                } else {
                    self?.indexedTranscriptionCount = count
                    Logger.shared.info("Found \(count) existing transcriptions in Spotlight index", category: .system)
                }
            }
        }
        
        query.start()
    }
    
    // MARK: - Transcription Indexing
    
    func indexTranscription(_ result: TranscriptionResult) async throws {
        guard isSpotlightIndexingEnabled else {
            throw SpotlightError.spotlightNotAvailable
        }
        
        guard result.isSuccess, !result.outputFiles.isEmpty else {
            throw SpotlightError.invalidTranscriptionResult
        }
        
        var searchableItems: [CSSearchableItem] = []
        
        for outputFile in result.outputFiles {
            let item = try createSearchableItem(for: outputFile, result: result)
            searchableItems.append(item)
        }
        
        return try await withCheckedThrowingContinuation { continuation in
            searchableIndex.indexSearchableItems(searchableItems) { [weak self] error in
                if let error = error {
                    Logger.shared.error("Failed to index transcription in Spotlight: \(error)", category: .system)
                    continuation.resume(throwing: error)
                } else {
                    self?.indexedTranscriptionCount += searchableItems.count
                    self?.lastIndexingUpdate = Date()
                    Logger.shared.info("Successfully indexed \(searchableItems.count) transcription files in Spotlight", category: .system)
                    continuation.resume()
                }
            }
        }
    }
    
    private func createSearchableItem(for outputFile: URL, result: TranscriptionResult) throws -> CSSearchableItem {
        let attributes = CSSearchableItemAttributeSet(contentType: .text)
        
        // Read transcription content
        let content = try String(contentsOf: outputFile, encoding: .utf8)
        let cleanContent = cleanTranscriptionContent(content, format: outputFile.pathExtension)
        
        // Basic attributes
        attributes.title = "Transcription: \(result.inputFile.lastPathComponent)"
        attributes.displayName = outputFile.lastPathComponent
        attributes.contentDescription = "Audio/Video transcription generated by WhisperLocal"
        attributes.textContent = cleanContent
        attributes.contentType = transcriptionDomain
        
        // File attributes
        attributes.path = outputFile.path
        attributes.url = outputFile
        attributes.contentCreationDate = result.processingTime.map { Date().addingTimeInterval(-$0) }
        attributes.contentModificationDate = Date()
        
        // Transcription specific metadata
        attributes.keywords = generateKeywords(from: result, content: cleanContent)
        attributes.subject = "Transcription"
        attributes.creator = "WhisperLocal"
        attributes.language = result.detectedLanguage ?? "en"
        
        // Audio/Video source information
        if let sourceFile = result.inputFile {
            attributes.alternateNames = [sourceFile.lastPathComponent]
            attributes.comment = "Transcribed from: \(sourceFile.path)"
        }
        
        // Model and quality information
        if let model = result.model {
            attributes.version = model
        }
        
        // Duration and processing info
        if let duration = result.audioDuration {
            attributes.duration = NSNumber(value: duration)
        }
        
        if let processingTime = result.processingTime {
            attributes.completionDate = Date().addingTimeInterval(-processingTime)
        }
        
        // Create searchable item
        let uniqueIdentifier = "\(transcriptionDomain).\(outputFile.lastPathComponent).\(UUID().uuidString)"
        let searchableItem = CSSearchableItem(
            uniqueIdentifier: uniqueIdentifier,
            domainIdentifier: transcriptionDomain,
            attributeSet: attributes
        )
        
        // Set expiration date (optional - remove after 1 year)
        searchableItem.expirationDate = Calendar.current.date(byAdding: .year, value: 1, to: Date())
        
        return searchableItem
    }
    
    private func cleanTranscriptionContent(_ content: String, format: String) -> String {
        switch format.lowercased() {
        case "srt":
            return cleanSRTContent(content)
        case "vtt":
            return cleanVTTContent(content)
        case "json":
            return cleanJSONContent(content)
        default:
            return content
        }
    }
    
    private func cleanSRTContent(_ content: String) -> String {
        let lines = content.components(separatedBy: .newlines)
        var cleanLines: [String] = []
        
        for line in lines {
            let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
            
            // Skip subtitle numbers and timestamps
            if !trimmed.isEmpty &&
               !trimmed.allSatisfy({ $0.isNumber }) &&
               !trimmed.contains("-->") {
                cleanLines.append(trimmed)
            }
        }
        
        return cleanLines.joined(separator: " ")
    }
    
    private func cleanVTTContent(_ content: String) -> String {
        let lines = content.components(separatedBy: .newlines)
        var cleanLines: [String] = []
        
        for line in lines {
            let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
            
            // Skip WebVTT headers and timestamps
            if !trimmed.isEmpty &&
               !trimmed.hasPrefix("WEBVTT") &&
               !trimmed.contains("-->") &&
               !trimmed.hasPrefix("NOTE") {
                cleanLines.append(trimmed)
            }
        }
        
        return cleanLines.joined(separator: " ")
    }
    
    private func cleanJSONContent(_ content: String) -> String {
        if let data = content.data(using: .utf8),
           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
           let text = json["text"] as? String {
            return text
        }
        return content
    }
    
    private func generateKeywords(from result: TranscriptionResult, content: String) -> [String] {
        var keywords: [String] = []
        
        // Add basic keywords
        keywords.append(contentsOf: ["transcription", "audio", "speech", "whisper"])
        
        // Add model name
        if let model = result.model {
            keywords.append(model)
        }
        
        // Add detected language
        if let language = result.detectedLanguage {
            keywords.append(language)
        }
        
        // Add format
        keywords.append(result.outputFiles.first?.pathExtension ?? "txt")
        
        // Extract meaningful words from content (simplified)
        let words = content.components(separatedBy: .whitespacesAndNewlines)
            .map { $0.trimmingCharacters(in: .punctuationCharacters) }
            .filter { $0.count > 3 }
            .prefix(10)
        
        keywords.append(contentsOf: words)
        
        return Array(Set(keywords)) // Remove duplicates
    }
    
    // MARK: - Search Functionality
    
    func searchTranscriptions(query: String, completion: @escaping ([SpotlightSearchResult]) -> Void) {
        guard isSpotlightIndexingEnabled else {
            completion([])
            return
        }
        
        let searchQuery = CSSearchQuery(
            queryString: "\(query) && contentType:'\(transcriptionDomain)'",
            attributes: [
                "kMDItemDisplayName",
                "kMDItemPath",
                "kMDItemTextContent",
                "kMDItemCreationDate",
                "kMDItemLanguage"
            ]
        )
        
        var results: [SpotlightSearchResult] = []
        
        searchQuery.foundItemsHandler = { items in
            for item in items {
                if let result = SpotlightSearchResult(from: item) {
                    results.append(result)
                }
            }
        }
        
        searchQuery.completionHandler = { error in
            DispatchQueue.main.async {
                if let error = error {
                    Logger.shared.error("Spotlight search failed: \(error)", category: .system)
                } else {
                    Logger.shared.info("Spotlight search completed with \(results.count) results", category: .system)
                }
                completion(results)
            }
        }
        
        searchQuery.start()
    }
    
    // MARK: - Index Management
    
    func deleteTranscriptionFromIndex(_ transcriptionFile: URL) async throws {
        let identifier = "\(transcriptionDomain).\(transcriptionFile.lastPathComponent)"
        
        return try await withCheckedThrowingContinuation { continuation in
            searchableIndex.deleteSearchableItems(withIdentifiers: [identifier]) { [weak self] error in
                if let error = error {
                    Logger.shared.error("Failed to delete transcription from Spotlight: \(error)", category: .system)
                    continuation.resume(throwing: error)
                } else {
                    self?.indexedTranscriptionCount = max(0, (self?.indexedTranscriptionCount ?? 1) - 1)
                    Logger.shared.info("Deleted transcription from Spotlight index", category: .system)
                    continuation.resume()
                }
            }
        }
    }
    
    func deleteAllTranscriptions() async throws {
        return try await withCheckedThrowingContinuation { continuation in
            searchableIndex.deleteSearchableItems(withDomainIdentifiers: [transcriptionDomain]) { [weak self] error in
                if let error = error {
                    Logger.shared.error("Failed to clear Spotlight index: \(error)", category: .system)
                    continuation.resume(throwing: error)
                } else {
                    self?.indexedTranscriptionCount = 0
                    self?.lastIndexingUpdate = Date()
                    Logger.shared.info("Cleared all transcriptions from Spotlight index", category: .system)
                    continuation.resume()
                }
            }
        }
    }
    
    // MARK: - Statistics
    
    func getIndexingStatistics() -> SpotlightStatistics {
        return SpotlightStatistics(
            isEnabled: isSpotlightIndexingEnabled,
            indexedCount: indexedTranscriptionCount,
            lastUpdate: lastIndexingUpdate,
            domainIdentifier: transcriptionDomain
        )
    }
}

// MARK: - Supporting Types

struct SpotlightSearchResult: Identifiable {
    let id = UUID()
    let title: String
    let path: String
    let content: String?
    let creationDate: Date?
    let language: String?
    
    init?(from item: CSSearchableItem) {
        guard let attributes = item.attributeSet,
              let title = attributes.displayName,
              let path = attributes.path else {
            return nil
        }
        
        self.title = title
        self.path = path
        self.content = attributes.textContent
        self.creationDate = attributes.contentCreationDate
        self.language = attributes.language
    }
    
    var url: URL {
        return URL(fileURLWithPath: path)
    }
    
    var excerpt: String {
        guard let content = content else { return "" }
        let words = content.components(separatedBy: .whitespacesAndNewlines).prefix(20)
        return words.joined(separator: " ") + (content.count > words.joined(separator: " ").count ? "..." : "")
    }
}

struct SpotlightStatistics {
    let isEnabled: Bool
    let indexedCount: Int
    let lastUpdate: Date?
    let domainIdentifier: String
    
    var statusDescription: String {
        if !isEnabled {
            return "Spotlight integration disabled"
        } else if indexedCount == 0 {
            return "No transcriptions indexed"
        } else {
            return "\(indexedCount) transcriptions indexed"
        }
    }
    
    var lastUpdateDescription: String {
        guard let lastUpdate = lastUpdate else {
            return "Never updated"
        }
        
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .full
        return "Updated \(formatter.localizedString(for: lastUpdate, relativeTo: Date()))"
    }
}

enum SpotlightError: LocalizedError {
    case spotlightNotAvailable
    case invalidTranscriptionResult
    case indexingFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .spotlightNotAvailable:
            return "Spotlight indexing is not available on this system"
        case .invalidTranscriptionResult:
            return "Invalid transcription result for Spotlight indexing"
        case .indexingFailed(let message):
            return "Spotlight indexing failed: \(message)"
        }
    }
}